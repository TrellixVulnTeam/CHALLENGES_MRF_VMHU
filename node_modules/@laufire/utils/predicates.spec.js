"use strict";

var _predicates = require("./predicates");

var _collection = require("./collection");

var _helpers = require("../test/helpers");

/* Tested */

/* Helpers */

/* Spec */
describe('Predicates', function () {
  test('isEqual returns a function to test value equality' + ' between the candidates.', function () {
    expect((0, _collection.filter)(_helpers.collection, (0, _predicates.isEqual)(_helpers.obj))).toEqual(_helpers.collection);
  });
  test('isSame returns a function to test referential equality' + ' between the candidates', function () {
    expect((0, _collection.filter)(_helpers.collection, (0, _predicates.isSame)(_helpers.collection.obj)).obj).toBe(_helpers.collection.obj);
  });
  test('isPart returns a function to test whether the tested object is' + ' wholly contained in any of the elements', function () {
    expect((0, _collection.filter)(_helpers.collection, (0, _predicates.isPart)(_helpers.extended)).obj).toBe(_helpers.collection.obj);
    expect((0, _collection.filter)(_helpers.collection, (0, _predicates.isPart)(_helpers.isolated))).toEqual({});
  });
  test('isPart is an alias for doesShare', function () {
    expect(_predicates.isPart).toBe(_predicates.doesContain);
  });
  test('truthy tests for truthy values', function () {
    expect((0, _helpers.sortArray)(_helpers.array.filter(_predicates.truthy))).toEqual((0, _helpers.sortArray)(_helpers.truthies));
    expect((0, _helpers.sortArray)(_helpers.falsies.filter(_predicates.truthy))).toEqual([]);
  });
  test('falsy tests for falsy values', function () {
    expect((0, _helpers.sortArray)(_helpers.array.filter(_predicates.falsy))).toEqual((0, _helpers.sortArray)(_helpers.falsies));
    expect((0, _helpers.sortArray)(_helpers.truthies.filter(_predicates.falsy))).toEqual([]);
  });
  test('everything allows everything through the filter.', function () {
    expect((0, _helpers.sortArray)(_helpers.array.filter(_predicates.everything))).toEqual((0, _helpers.sortArray)(_helpers.array));
  });
  test('nothing allows nothing through the filter.', function () {
    expect((0, _helpers.sortArray)(_helpers.array.filter(_predicates.nothing))).toEqual([]);
  });
  test('first tests for the first occurrence of the element in ' + 'the collection.', function () {
    expect(_helpers.truthies.concat(_helpers.truthies).filter(_predicates.first)).toEqual(_helpers.truthies);
  });
  test('unique is an alias of first.', function () {
    expect(_predicates.unique).toBe(_predicates.first);
  });
  test('not returns the inverse of the given predicate.', function () {
    expect((0, _collection.filter)(_helpers.collection, (0, _predicates.not)((0, _predicates.isEqual)(_helpers.obj)))).not.toEqual(_helpers.collection);
    expect((0, _collection.filter)(_helpers.collection, (0, _predicates.not)((0, _predicates.isSame)(_helpers.obj))).obj).not.toBe(_helpers.obj);
    expect((0, _collection.filter)(_helpers.collection, (0, _predicates.not)((0, _predicates.isPart)(_helpers.extended))).obj).not.toBe(_helpers.obj);
    expect((0, _helpers.sortArray)(_helpers.array.filter((0, _predicates.not)(_predicates.truthy)))).toEqual((0, _helpers.sortArray)(_helpers.falsies));
    expect((0, _helpers.sortArray)(_helpers.array.filter((0, _predicates.not)(_predicates.falsy)))).toEqual((0, _helpers.sortArray)(_helpers.truthies));
    expect((0, _helpers.sortArray)(_helpers.array.filter((0, _predicates.not)(_predicates.everything)))).toEqual([]);
    expect((0, _helpers.sortArray)(_helpers.array.filter((0, _predicates.not)(_predicates.nothing)))).toEqual((0, _helpers.sortArray)(_helpers.array));
  });
  test('and returns a function to test the candidates to pass' + ' all the given predicates.', function () {
    expect((0, _collection.filter)(_helpers.collection, (0, _predicates.and)((0, _predicates.isSame)(_helpers.obj), (0, _predicates.isSame)(_helpers.cloned)))).toEqual({});
    expect((0, _collection.filter)(_helpers.collection, (0, _predicates.and)((0, _predicates.isSame)(_helpers.obj), (0, _predicates.isEqual)(_helpers.cloned)))).toEqual({
      obj: _helpers.obj
    });
  });
  test('or returns a function to test the candidates to pass' + ' at least one among multiple predicates.', function () {
    expect((0, _collection.filter)(_helpers.collection, (0, _predicates.or)((0, _predicates.isSame)(_helpers.obj), (0, _predicates.isSame)(_helpers.cloned)))).toEqual(_helpers.collection);
    expect((0, _collection.filter)(_helpers.collection, (0, _predicates.or)((0, _predicates.isSame)(_helpers.extended), (0, _predicates.isEqual)(_helpers.extended)))).toEqual({});
  });
  test('onProp returns a function to test the given prop across candidates' + ' of a collection.', function () {
    expect((0, _collection.filter)(_helpers.collection, (0, _predicates.onProp)('a', (0, _predicates.isEqual)(1)))).toEqual(_helpers.collection);
    expect((0, _collection.filter)(_helpers.extendedCollection, (0, _predicates.onProp)('d', (0, _predicates.isEqual)(4)))).toEqual({
      extended: _helpers.extended
    });
  });
  describe('generators pass all available arguments to the given predicates.', function () {
    var generators = {
      and: _predicates.and,
      or: _predicates.or,
      not: _predicates.not
    };
    test.each((0, _collection.keys)(generators))('testing the generator: %s', function (key) {
      var _expect;

      var predicate = jest.fn();
      var args = [_helpers.obj.a, 'a', _helpers.obj];
      (0, _collection.filter)(_helpers.obj, generators[key](predicate));

      (_expect = expect(predicate)).toHaveBeenCalledWith.apply(_expect, args);
    });
    test('testing the generator: onProp.', function () {
      var predicate = jest.fn();
      var collection = {
        obj: _helpers.obj
      };
      var prop = 'a';
      (0, _collection.filter)(collection, (0, _predicates.onProp)(prop, predicate));
      expect(predicate).toHaveBeenCalledWith(_helpers.obj[prop], 'obj', collection);
    });
  });
  test('predicate derives predicates from relevant ' + 'collection functions', function () {
    expect((0, _collection.filter)(_helpers.extendedCollection, (0, _predicates.predicate)(_collection.equals, _helpers.extended))).toEqual({
      extended: _helpers.extended
    });
    expect((0, _collection.filter)(_helpers.extendedCollection, (0, _predicates.predicate)(_collection.contains, _helpers.extension))).toEqual({
      extended: _helpers.extended
    });
    expect((0, _collection.filter)(_helpers.extendedCollection, (0, _predicates.predicate)(_collection.shares, _helpers.extension, 'd'))).toEqual({
      extended: _helpers.extended
    });
  });
});