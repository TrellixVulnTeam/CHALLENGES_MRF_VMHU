"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.withProb = exports.stringSeeds = exports.rndValueWeighted = exports.rndValues = exports.rndValue = exports.rndOfString = exports.rndString = exports.rndBetween = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _collection = require("./collection");

var _lib = require("./lib");

/**
 * Random functions to help with testing.
 */

/* Imports */

/* Exports */
var stringSeeds = {
  "char": 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
  hex: '0123456789ABCDEF',
  num: '0123456789'
};
/**
 *
 * @param {Integer} [0] from - The start of the range.
 * @param {Integer} [1] to - The end of the range.
 * @returns {integer} A random number between from and to.
 */

exports.stringSeeds = stringSeeds;
var rndBetween = _lib.rndBetween;
/*
	NOTE: To by-pass seed matching of predefined names, use them twice.
	IE: 'charchar' instead of 'char'.
*/

/**
 * Get a random string from the pre-defined seed / custom string.
 * @param {integer} [8] length
 * @param {string} [char] seed
 * @returns { string} A random string.
 */
// eslint-disable-next-line no-magic-numbers

exports.rndBetween = rndBetween;

var rndString = function rndString() {
  var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
  var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'char';
  var seedString = stringSeeds[seed] || seed;
  var seedCharCount = seedString.length - 1;
  var ret = ''; // eslint-disable-next-line no-param-reassign

  while (length--) {
    ret += seedString.substr(rndBetween(0, seedCharCount), 1);
  }

  return ret;
};
/**
 * Get a random substring from the given string.
 * @param {string} string - The seed string.
 * @returns {string} The resulting random substring.
 */


exports.rndString = rndString;

var rndOfString = function rndOfString(string) {
  return Array.from(new Set(rndString(rndBetween(1, string.length), string).split(''))).join('');
};

exports.rndOfString = rndOfString;

var rndValue = function rndValue(collection) {
  var items = (0, _collection.values)(collection);
  return items[rndBetween(0, items.length - 1)];
};

exports.rndValue = rndValue;

var rndValues = function () {
  // eslint-disable-next-line no-magic-numbers
  var skip = function skip(array, i) {
    return [].concat((0, _toConsumableArray2["default"])(array.slice(0, i)), (0, _toConsumableArray2["default"])(array.slice(i + 1)));
  };

  return function (iterable) {
    var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var array = (0, _collection.values)(iterable);
    return array.reduce(function (t) {
      return t.length > count ? skip(t, rndBetween(0, t.length - 1)) : t;
    }, array);
  };
}();

exports.rndValues = rndValues;

var rndValueWeighted = function rndValueWeighted(weights) {
  var candidates = (0, _collection.keys)(weights);
  var boundaries = (0, _collection.values)((0, _collection.map)(weights, function (value, key) {
    return value + candidates.slice(0, candidates.indexOf(key)).reduce(function (t, c) {
      return t + weights[c];
    }, 0);
  }));
  var start = 0;
  var end = (boundaries.slice(-1)[0] || 1) - 1;
  return function () {
    var marker = rndBetween(start, end);
    return candidates[boundaries.findIndex(function (boundary) {
      return boundary > marker;
    })];
  };
};

exports.rndValueWeighted = rndValueWeighted;

var withProb = function withProb(prob) {
  // NOTE: Precision is not dynamic to avoid js floating point arithmetic.
  var precision = 1000;
  var inverse = 1 / prob * precision - 1;
  return function () {
    return rndBetween(0, inverse) < precision;
  };
};

exports.withProb = withProb;