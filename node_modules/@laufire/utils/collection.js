"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sort = exports.shuffle = exports.shares = exports.hasSame = exports.range = exports.findIndex = exports.findKey = exports.find = exports.adopt = exports.dict = exports.spread = exports.pick = exports.gather = exports.contains = exports.equals = exports.secure = exports.diff = exports.patch = exports.fill = exports.compose = exports.overlay = exports.merge = exports.combine = exports.squash = exports.clone = exports.assign = exports.shell = exports.translate = exports.rename = exports.flipMany = exports.flip = exports.result = exports.select = exports.omit = exports.sanitize = exports.clean = exports.has = exports.walk = exports.traverse = exports.reduce = exports.filter = exports.map = exports.each = exports.props = exports.fromEntries = exports.entries = exports.values = exports.keys = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _reflection = require("./reflection");

var _lib = require("./lib");

var _sorters = require("./sorters");

/**
* Helper functions to deal with collections (collections).
*
* Notes:
* 	* Keys with undefined values are treated as non-existent,
* 		so to allow for simplicity.
*/

/*
TODO: Complete the doc comments.
*/

/* NOTE: Exporting named imports (like keys) turns them into getters
 (probably by the compiler), this leads to some inconsistencies when
 mocking with jest. Hence, they are imported from the source.
*/
var assign = Object.assign,
    entries = Object.entries,
    keys = Object.keys,
    values = Object.values;
exports.values = values;
exports.keys = keys;
exports.entries = entries;
exports.assign = assign;
var abs = Math.abs,
    floor = Math.floor,
    sign = Math.sign;

var toArray = function toArray(value) {
  return (0, _reflection.isArray)(value) ? value : [value];
};

var keyArray = function keyArray(object) {
  return (0, _reflection.isArray)(object) ? object.map(String) : keys(object);
};

var combineObjects = function combineObjects(base, extension) {
  return (0, _reflection.isArray)(base) && (0, _reflection.isArray)(extension) // eslint-disable-next-line no-sequences
  ? (base.push.apply(base, (0, _toConsumableArray2["default"])(extension)), base) : (keys(extension).forEach(function (key) {
    var child = base[key];
    var childExtension = extension[key];
    base[key] = (0, _reflection.isIterable)(childExtension) ? (0, _reflection.isIterable)(child) ? combineObjects(child, childExtension) // eslint-disable-next-line no-use-before-define
    : clone(childExtension) : childExtension;
  }), base);
};

var mergeObjects = function mergeObjects(base, extension) {
  keys(extension).forEach(function (key) {
    var child = base[key];
    var childExtension = extension[key];
    base[key] = (0, _reflection.isIterable)(childExtension) ? (0, _reflection.isIterable)(child) ? mergeObjects(child, childExtension) // eslint-disable-next-line no-use-before-define
    : clone(childExtension) : childExtension;
  });
  return base;
};

var overlayObjects = function overlayObjects(base, extension) {
  keys(extension).forEach(function (key) {
    var child = base[key];
    var childExtension = extension[key];
    base[key] = (0, _reflection.isDict)(childExtension) ? (0, _reflection.isDict)(child) ? overlayObjects(child, childExtension) // eslint-disable-next-line no-use-before-define
    : clone(childExtension) : childExtension;
  });
  return base;
}; // eslint-disable-next-line id-length


var freeze = Object.freeze,
    preventExtensions = Object.preventExtensions,
    seal = Object.seal;
/* Exports */

/*
TODO: Decide whether keys on arrays should return numbers,
	instead of strings.
*/

/**
 * Returns an empty container of the same type as the given collection.
 * @param {*} collection The collection to get a shell for.
 */

var shell = function shell(collection) {
  return (0, _reflection.isArray)(collection) ? [] : {};
};

exports.shell = shell;

var fromEntries = function fromEntries(kvPairs) {
  return kvPairs.reduce(function (agg, pair) {
    agg[pair[0]] = pair[1];
    return agg;
  }, {});
}; // An Array.map like function for Iterables.


exports.fromEntries = fromEntries;

var map = function map(collection, cb) {
  var ret = shell(collection);
  keys(collection).forEach(function (key) {
    return ret[key] = cb(collection[key], key);
  });
  return ret;
};
/*
NOTE: The standard each implementation is avoided, as it doesn't align -
	with the principle of having a return value.
*/


exports.map = map;
var each = map; // An Array.filter like function for Objects.

/*
TODO: Try accommodating arrays. The issue is that Object.keys works with
	sparse keys, unlike [].keys, which does with dense.
*/

exports.each = each;

var filter = function filter(obj, cb) {
  var ret = shell(obj);
  keys(obj).forEach(function (key) {
    if (cb(obj[key], key, obj)) ret[key] = obj[key];
  });
  return ret;
}; // An Array.reduce like function for Objects.


exports.filter = filter;

var reduce = function reduce(obj, reducer, initial) {
  var acc = initial;
  keys(obj).forEach(function (key) {
    acc = reducer(acc, obj[key], key, obj);
  });
  return acc;
};

exports.reduce = reduce;

var find = function find(collection, predicate) {
  return collection[keys(collection).find(function (key) {
    return predicate(collection[key], key);
  })];
};

exports.find = find;

var findKey = function findKey(collection, predicate) {
  var colKeys = keys(collection);
  return colKeys[colKeys.findIndex(function (key) {
    return predicate(collection[key], key);
  })];
};

exports.findKey = findKey;
var findIndex = findKey;
/*
* Recursively passes all the primitives in the given collection
* to the given callback.
*/

exports.findIndex = findIndex;

var traverse = function traverse(obj, cb) {
  return map(obj, function (value, key) {
    return (0, _reflection.isIterable)(value) ? traverse(value, cb) : cb(value, key, obj);
  });
};
/*
* Recursively passes all the props of the given collections
* to the given callback.
*/


exports.traverse = traverse;

var walk = function walk(obj, cb) {
  return map(obj, function (value, key) {
    return (0, _reflection.isIterable)(value) && walk(value, cb), cb(value, key, obj);
  });
};

exports.walk = walk;

var clone = function () {
  var cloneObj = function cloneObj(obj) {
    return map(obj, clone);
  };

  var cloneArray = function cloneArray(arr) {
    return arr.map(clone);
  };

  return function (value) {
    return (0, _reflection.isDict)(value) ? cloneObj(value) : (0, _reflection.isArray)(value) ? cloneArray(value) : value;
  };
}();
/**
 * Has tells whether the given collection has the given value.
 * @param {*} collection The collection to collect the values from.
 * @param {*} value The props to collect from the children of the collection.
 */


exports.clone = clone;

var has = function has(collection, value) {
  return values(collection).indexOf(value) > -1;
}; // NOTE: Clean does not clean recursively to allow for shallow cleaning.


exports.has = has;

var clean = function clean(collection) {
  if ((0, _reflection.isArray)(collection)) return collection.filter(function (value) {
    return value !== undefined;
  });
  var ret = {};
  var objKeys = keys(collection);
  var l = objKeys.length;
  var i = 0;

  while (i < l) {
    var key = objKeys[i++];
    var val = collection[key];
    if (val !== undefined) ret[key] = val;
  }

  return ret;
};
/* A recursive clean */


exports.clean = clean;

var sanitize = function sanitize(collection) {
  return clean(map(collection, function (value) {
    return (0, _reflection.isIterable)(value) ? sanitize(value) : value;
  }));
};

exports.sanitize = sanitize;

var props = function props(obj, objProps) {
  return objProps.map(function (prop) {
    return obj[prop];
  });
};
/*
TODO: select uses key from objects and values from arrays streamline this.
	This would be a #BREAKING change. keyArray is the source for this confusion.
*/


exports.props = props;

var select = function select(collection, selector) {
  return keyArray(selector).reduce(function (aggregate, prop) {
    return collection[prop] !== undefined // eslint-disable-next-line no-sequences
    && (aggregate[prop] = collection[prop]), aggregate;
  }, shell(collection));
};
/*
TODO: omit uses key from objects and values from arrays streamline this.
	This would be a #BREAKING change. keyArray is the source for this confusion.
*/


exports.select = select;

var omit = function omit(obj, selector) {
  var propsToOmit = keyArray(selector);
  return keys(obj).filter(function (prop) {
    return !propsToOmit.includes(prop);
  }) // eslint-disable-next-line no-return-assign
  .reduce(function (aggregate, prop) {
    return aggregate[prop] = obj[prop], aggregate;
  }, shell(obj));
};
/**
 * Gathers the given props from the children of the given collection,
 * as a collection.
 * @param {*} collection The collection to collect the values from.
 * @param {...any} props The props to collect from the children
 * of the collection.
 */
// eslint-disable-next-line no-shadow


exports.omit = omit;

var gather = function gather(collection) {
  var propShell = shell(collection);
  var ret = shell(values(collection)[0]);

  for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    props[_key - 1] = arguments[_key];
  }

  props.forEach(function (prop) {
    var child = shell(propShell);
    map(collection, function (value, key) {
      return value[prop] !== undefined && (child[key] = value[prop]);
    });
    ret[prop] = child;
  });
  return ret;
};
/**
 * Picks the given prop from the children of the given collection,
 * as a collection.
 * @param {*} collection The collection to collect the values from.
 * @param {any} props The props to collect from the children of the collection.
 */


exports.gather = gather;

var pick = function pick(collection, prop) {
  return gather(collection, prop)[prop];
}; // TODO: Fix the description.

/**
 * Spreads the children of given seeds collection into
 * the given base collection.
 * @param {collection} base The collection to collect the values from.
 * @param {collection} seeds The seeds collection from where
 * the props are spread.
 */


exports.pick = pick;

var spread = function spread(base, seeds) {
  return map(seeds, function (propValues, targetProp) {
    return map(propValues, function (value, targetKey) {
      return base[targetKey][targetProp] = value;
    });
  }) && base;
};
/**
 * Combines multiple objects and their descendants with the given base object.
 * When immutability is required, a shell could be passed as the base object.
 * @param {collection} base The base collection on which
 * the extensions would be combined to.
 * @param {...collection} extensions The extensions to be combined.
 */


exports.spread = spread;

var combine = function combine(base) {
  for (var _len2 = arguments.length, extensions = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    extensions[_key2 - 1] = arguments[_key2];
  }

  return extensions.forEach(function (extension) {
    return extension !== undefined && combineObjects(base, extension);
  }) || base;
};
/**
 * Merges multiple objects and their descendants with to the given base object.
 * When immutability is required, a shell could be passed as the base object.
 * @param {collection} base The base collection on which
 * the extensions would be merged to.
 * @param {...collection} extensions The extensions to be merged.
 */


exports.combine = combine;

var merge = function merge(base) {
  for (var _len3 = arguments.length, extensions = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    extensions[_key3 - 1] = arguments[_key3];
  }

  return extensions.forEach(function (extension) {
    return extension !== undefined && mergeObjects(base, extension);
  }) || base;
};
/**
 * Overlays multiple objects and their descendants with the given base object.
 * When immutability is required, a shell could be passed as the base object.
 * @param {collection} base The base collection on which
 * the extensions would be overlaid to.
 * @param {...collection} extensions The extensions to be overlaid.
 */


exports.merge = merge;

var overlay = function overlay(base) {
  for (var _len4 = arguments.length, extensions = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    extensions[_key4 - 1] = arguments[_key4];
  }

  return extensions.forEach(function (extension) {
    return extension !== undefined && overlayObjects(base, extension);
  }) || base;
}; // TODO: Maintain the key order, similar to merge.

/**
 * Fills the missing properties of the given base from those of the extensions.
 * @param {collection} base The base collection on which
 * the extensions would be filled.
 * @param {...collection} extensions The extensions with properties to fill.
 */


exports.overlay = overlay;

var fill = function fill(base) {
  for (var _len5 = arguments.length, extensions = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
    extensions[_key5 - 1] = arguments[_key5];
  }

  return merge(base, merge.apply(void 0, [{}].concat((0, _toConsumableArray2["default"])(extensions.reverse()), [base])));
}; // Merges an array of objects / object-arrays into a single object.


exports.fill = fill;

var squash = function squash() {
  for (var _len6 = arguments.length, objects = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    objects[_key6] = arguments[_key6];
  }

  return assign.apply(void 0, [{}].concat((0, _toConsumableArray2["default"])(objects.reduce(function (aggregate, value) {
    return [].concat((0, _toConsumableArray2["default"])(aggregate), (0, _toConsumableArray2["default"])(toArray(value)));
  }, []))));
};
/**
 * Retrieves the value, notified by a path, from a nested map.
 * Slashes are used as the separator for readability.
 * Starting paths with a slash yields better accuracy.
 * @param {collection} obj The collection to look into.
 * @param {string} path The path to look for. Slash is the separator.
 * And backslash is the escape char.
 * @returns {*} The value from the path or undefined.
 */


exports.squash = squash;

var result = function () {
  var initialSlash = /^\//;
  var matcher = /(?:(?:[^/\\]|\\.)*\/)/g;
  var escapedSequence = /\\(.)/g;
  return function (obj, path) {
    var parts = ("".concat(path, "/").replace(initialSlash, '').match(matcher) || []).map(function (part) {
      return part.replace(escapedSequence, '$1').slice(0, -1);
    });
    var partCount = parts.length;
    var currentObject = obj;
    var cursor = 0;

    while (cursor < partCount && (0, _reflection.isIterable)(currentObject)) {
      currentObject = currentObject[parts[cursor++]];
    }

    return currentObject;
  };
}(); // Swaps the keys and values of a map.


exports.result = result;

var flip = function flip(obj) {
  var ret = {};
  keys(obj).forEach(function (key) {
    return ret[obj[key]] = key;
  });
  return ret;
};
/*
Converts a one-to-many map (an object of array values)
as an one-to-one inverted map, to ease reverse lookups.
IE: {'a': ['b', 'c']} => {'b': 'a', 'c': 'a'}.
*/


exports.flip = flip;

var flipMany = function flipMany(obj) {
  var ret = {};
  keys(obj).forEach(function (key) {
    return obj[key].forEach(function (item) {
      return ret[item] = key;
    });
  });
  return ret;
};

exports.flipMany = flipMany;

var translate = function translate(source, translationMap) {
  return entries(source).reduce(function (ret, _ref) {
    var _ref2 = (0, _slicedToArray2["default"])(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];

    return assign(ret, (0, _defineProperty2["default"])({}, key, translationMap[value]));
  }, shell(source));
}; // Ex: ([3, 5], {1: "a"}) => {a: 5}


exports.translate = translate;

var rename = function rename(source, renameMap) {
  return entries(renameMap).reduce(function (ret, _ref3) {
    var _ref4 = (0, _slicedToArray2["default"])(_ref3, 2),
        key = _ref4[0],
        value = _ref4[1];

    return assign(ret, (0, _defineProperty2["default"])({}, value, source[key]));
  }, shell(source));
};

exports.rename = rename;

var compose = function compose() {
  for (var _len7 = arguments.length, objects = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
    objects[_key7] = arguments[_key7];
  }

  var keysToPick = keys(objects[0]);
  var keysLength = keysToPick.length;
  return objects.reduce(function (aggregate, current) {
    var i = 0;

    while (i < keysLength) {
      var key = keysToPick[i++];
      var val = current[key];
      if (val !== undefined) aggregate[key] = val;
    }

    return aggregate;
  }, {});
};

exports.compose = compose;

var patch = function patch(base, extension) {
  return sanitize(merge(clone(base), extension));
};

exports.patch = patch;

var diff = function diff(base, compared) {
  var difference = shell(base);
  keys(compared).forEach(function (key) {
    var baseChild = base[key];
    var comparedChild = compared[key];

    if (baseChild !== comparedChild) {
      difference[key] = (0, _reflection.isIterable)(comparedChild) ? diff(baseChild, comparedChild) : comparedChild;
    }
  });
  keys(base).forEach(function (key) {
    return compared[key] === undefined && (difference[key] = undefined);
  });
  return difference;
};

exports.diff = diff;

var secure = function secure(object) {
  return freeze(preventExtensions(seal(map(object, function (value) {
    return (0, _reflection.isIterable)(value) ? secure(value) : value;
  }))));
};

exports.secure = secure;

var contains = function contains(base, compared) {
  return (0, _reflection.isIterable)(base) && (0, _reflection.isIterable)(compared) ? keys(compared).findIndex(function (key) {
    return !contains(base[key], compared[key]);
  }) === -1 : base === compared;
};

exports.contains = contains;

var equals = function equals(base, compared) {
  return (0, _reflection.isIterable)(base) && (0, _reflection.isIterable)(compared) ? keys(base).length === keys(compared).length && keys(base).findIndex(function (key) {
    return !equals(base[key], compared[key]);
  }) === -1 : base === compared;
};
/* Tests the collections to have same children. */


exports.equals = equals;

var hasSame = function hasSame(base, compared) {
  return keys(base).length === keys(compared).length && findKey(base, function (value, key) {
    return value !== compared[key];
  }) === undefined;
};

exports.hasSame = hasSame;

var dict = function dict(collection) {
  return fromEntries(map(collection, function (value, key) {
    return [key, value];
  }));
};

exports.dict = dict;

var adopt = function adopt(base) {
  for (var _len8 = arguments.length, extensions = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {
    extensions[_key8 - 1] = arguments[_key8];
  }

  return each(extensions, function (extension) {
    return each(extension, function (value, key) {
      return base[key] = value;
    });
  });
};

exports.adopt = adopt;

var range = function range() {
  var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 9;
  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  return Array.from({
    length: sign(end - start) !== sign(step) || !step ? 0 : floor(abs(end - start) / abs(step))
  }, function (dummy, i) {
    return i * step + start;
  });
};

exports.range = range;

var shares = function shares(left, right) {
  var prop = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'id';
  return left[prop] === right[prop];
};

exports.shares = shares;

var shuffle = function shuffle(collection) {
  var ixs = keys(collection);
  var newIxs = [];

  while (ixs.length) {
    newIxs.push(ixs.splice((0, _lib.rndBetween)(0, ixs.length - 1), 1)[0]);
  }

  return newIxs.reduce((0, _reflection.isArray)(collection) // eslint-disable-next-line no-return-assign
  ? function (t, c, i // eslint-disable-next-line no-sequences
  ) {
    return t[i] = collection[c], t;
  } // eslint-disable-next-line no-return-assign
  : function (t, c) {
    return t[c] = collection[c], t;
  }, shell(collection));
};

exports.shuffle = shuffle;

var sort = function sort(collection) {
  var sorter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _sorters.ascending;
  return (0, _reflection.isArray)(collection) ? collection.slice().sort(sorter) : fromEntries(entries(collection).sort(function (a, b) {
    return sorter(a[1], b[1]);
  }));
};

exports.sort = sort;