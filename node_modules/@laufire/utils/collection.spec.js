"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _collection = require("./collection");

var _helpers = require("../test/helpers");

var _lib = require("./lib");

var _reflection = require("./reflection");

var _sorters = require("./sorters");

var _reducers = require("./reducers");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var mockObj = function mockObj(keys, value) {
  return (0, _collection.fromEntries)((0, _collection.map)(keys, function (key) {
    return [key, (0, _reflection.isDefined)(value) ? value : key];
  }));
};
/* Spec */


describe('Collection', function () {
  /* Mocks and Stubs */
  var simpleObj = (0, _collection.secure)({
    a: 1,
    b: 2
  });
  var simpleArray = (0, _collection.secure)([1, 2]);
  var nestedObj = (0, _collection.secure)({
    a: 1,
    b: 2,
    c: {
      d: {
        e: 5
      }
    }
  });
  var complexArray = [{
    innerArray: [1, 3],
    dirtyArray: [undefined, 1]
  }];
  var complexObject = (0, _collection.secure)({
    single: 'single',
    parent: {
      child: {
        grandChild: 'grandChild'
      },
      '/unescaped/child': 'unescaped/child',
      'escaped\\/child': 'escaped\\/child'
    },
    undefinedProp: undefined,
    array: (0, _collection.clone)(simpleArray),
    primitiveOverlay: null,
    iterableOverlay: null,
    complexArray: complexArray
  });
  var baseObject = (0, _collection.secure)({
    a: 1,
    b: 2,
    c: 1,
    d: 'only in base',
    e: [0]
  });
  var comparedObject = (0, _collection.secure)({
    a: 1,
    b: 3,
    c: {
      d: 3
    },
    e: [0, 1],
    f: 'only in compared'
  });
  /* Helpers */

  var stitch = function stitch(val, key) {
    return key + val;
  };
  /* Tests */


  test('shell returns an empty container of the same type' + ' as the given iterable', function () {
    expect((0, _collection.shell)(simpleObj)).toEqual({});
    expect((0, _collection.shell)(simpleArray)).toEqual([]);
  });
  test('clean removes undefined props', function () {
    expect((0, _collection.clean)(complexObject)).not.toHaveProperty('undefinedProperty');
    expect((0, _collection.clean)([undefined, 1])).toEqual([1]);
  });
  test('sanitize removes undefined props recursively', function () {
    var sanitized = (0, _collection.sanitize)(complexObject);
    expect(sanitized).not.toHaveProperty('undefinedProperty');
    expect(sanitized.complexArray[0].dirtyArray).toEqual([1]);
  });
  test('each is an alias for map', function () {
    expect(_collection.map).toEqual(_collection.each);
  });
  test('map works with all the properties of the object' + ' and builds a new object', function () {
    expect((0, _collection.map)(simpleObj, stitch)).toEqual({
      a: 'a1',
      b: 'b2'
    });
  });
  test('map handles arrays with keys instead of indexes', function () {
    expect((0, _collection.map)([1, 2], stitch)).toEqual(['01', '12']);
  });
  test('filter filters the properties of the given iterable using' + ' the passed filter function', function () {
    expect((0, _collection.filter)(simpleObj, (0, _helpers.getPredicate)(1))).toEqual({
      a: 1
    });
    expect((0, _collection.filter)(simpleArray, (0, _helpers.getPredicate)(1))).toEqual([1]);
  });
  test('reduce reduces the given collection.', function () {
    expect((0, _collection.reduce)(simpleObj, _reducers.sum, 0)).toEqual(3);
    expect((0, _collection.reduce)(simpleArray, _reducers.product, 1)).toEqual(2);
  });
  test('traverse recursively traverses through a given object and' + ' builds a new object from its primitives', function () {
    expect((0, _collection.traverse)(nestedObj, stitch)).toEqual({
      a: 'a1',
      b: 'b2',
      c: {
        d: {
          e: 'e5'
        }
      }
    });
  });
  test('has tells whether the given iterable has the given value', function () {
    expect((0, _collection.has)(simpleObj, 1)).toEqual(true);
    expect((0, _collection.has)(simpleArray, 1)).toEqual(true);
    expect((0, _collection.has)(simpleObj, 0)).toEqual(false);
    expect((0, _collection.has)(simpleArray, 0)).toEqual(false);
  });
  test('walk recursively walks through a given object and' + ' builds a new object from its primitives and iterables', function () {
    var classify = function classify(value) {
      return (0, _typeof2["default"])(value);
    };

    expect((0, _collection.walk)(nestedObj, classify)).toEqual({
      a: 'number',
      b: 'number',
      c: 'object'
    });
  });
  test('clone clones the given object', function () {
    var cloned = (0, _collection.clone)(complexObject);
    expect(cloned).toEqual(complexObject);
  });
  test('squash squashes objects and object lists' + ' to a single object', function () {
    var squashed = (0, _collection.squash)({
      a: 1
    }, [{
      b: 2
    }], {
      c: 3
    });
    expect(squashed).toEqual({
      a: 1,
      b: 2,
      c: 3
    });
  });
  test('merge merges multiple objects into one', function () {
    var base = (0, _collection.clone)(complexObject);
    var bottomLevelBase = (0, _collection.clone)(complexObject);
    var topLevelBase = (0, _collection.clone)(complexObject);
    var propToDelete = 'single';
    var newValue = 'new value';
    bottomLevelBase.primitiveOverlay = 0;
    bottomLevelBase.iterableOverlay = {};
    var bottomLevel = (0, _collection.secure)(bottomLevelBase);
    delete topLevelBase[propToDelete];
    topLevelBase.newProperty = newValue;
    topLevelBase.parent.child.grandChild = newValue;
    topLevelBase.complexArray.innerArray = [0];
    topLevelBase.primitiveOverlay = simpleObj;
    topLevelBase.iterableOverlay = simpleObj;
    var topLevel = (0, _collection.secure)(topLevelBase);
    var merged = (0, _collection.merge)(base, bottomLevel, topLevel);
    expect(base).not.toEqual(complexObject);
    expect(merged).toHaveProperty(propToDelete);
    expect(merged.newProperty).toEqual(newValue);
    expect(merged.parent.child.grandChild).toEqual(newValue);
    expect(merged.primitiveOverlay).toEqual(simpleObj);
    expect(topLevelBase.iterableOverlay).toEqual(simpleObj);
    expect(merged.complexArray !== topLevel.complexArray).toEqual(true);
    expect(merged.complexArray.innerArray[0]).toEqual(0);
  });
  test('overlay overlays multiple objects into one', function () {
    var base = (0, _collection.clone)(complexObject);
    var bottomLevelBase = (0, _collection.clone)(complexObject);
    var topLevelBase = (0, _collection.clone)(complexObject);
    var propToDelete = 'single';
    var newValue = 'new value';
    bottomLevelBase.primitiveOverlay = 0;
    bottomLevelBase.iterableOverlay = {};
    var bottomLevel = (0, _collection.secure)(bottomLevelBase);
    delete topLevelBase[propToDelete];
    topLevelBase.newProperty = newValue;
    topLevelBase.parent.child.grandChild = newValue;
    topLevelBase.complexArray.innerArray = [0];
    topLevelBase.primitiveOverlay = simpleObj;
    topLevelBase.iterableOverlay = simpleObj;
    var topLevel = (0, _collection.secure)(topLevelBase);
    var overlaid = (0, _collection.overlay)(base, bottomLevel, topLevel);
    expect(base).not.toEqual(complexObject);
    expect(overlaid).toHaveProperty(propToDelete);
    expect(overlaid.newProperty).toEqual(newValue);
    expect(overlaid.parent.child.grandChild).toEqual(newValue);
    expect(overlaid.primitiveOverlay).toEqual(simpleObj);
    expect(topLevelBase.iterableOverlay).toEqual(simpleObj);
    expect(overlaid.complexArray === topLevel.complexArray).toEqual(true);
    expect(overlaid.complexArray.innerArray === topLevel.complexArray.innerArray).toEqual(true);
  });
  test('combine combines multiple objects into one', function () {
    var base = (0, _collection.clone)(complexObject);
    var underlayBase = (0, _collection.clone)(complexObject);
    var overlayBase = (0, _collection.clone)(complexObject);
    var propToDelete = 'single';
    var newValue = 'new value';
    underlayBase.primitiveOverlay = 0;
    underlayBase.iterableOverlay = {};
    var underlay = (0, _collection.secure)(underlayBase);
    delete overlayBase[propToDelete];
    overlayBase.newProperty = newValue;
    overlayBase.parent.child.grandChild = newValue;
    overlayBase.complexArray.innerArray = [0];
    overlayBase.primitiveOverlay = simpleObj;
    overlayBase.iterableOverlay = simpleObj;
    var overlay = (0, _collection.secure)(overlayBase);
    var combined = (0, _collection.combine)(base, underlay, overlay);
    expect(base).not.toEqual(complexObject);
    expect(combined).toHaveProperty(propToDelete);
    expect(combined.newProperty).toEqual(newValue);
    expect(combined.parent.child.grandChild).toEqual(newValue);
    expect(combined.array).toEqual(complexObject.array.concat(underlayBase.array).concat(overlayBase.array));
    expect(combined.primitiveOverlay).toEqual(simpleObj);
    expect(overlayBase.iterableOverlay).toEqual(simpleObj);
    expect(combined.complexArray).toEqual([complexObject.complexArray[0], underlayBase.complexArray[0], overlayBase.complexArray[0]]);
  });
  test('merge and combine work with multiple extensions', function () {
    expect((0, _collection.merge)({
      a: 1
    }, {
      b: 2
    }, {
      c: 3
    })).toEqual({
      a: 1,
      b: 2,
      c: 3
    });
    expect((0, _collection.combine)({
      a: [1]
    }, {
      a: [2],
      c: 3
    })).toEqual({
      a: [1, 2],
      c: 3
    });
  });
  test('merge and combine ignore undefined values as extensions', function () {
    expect((0, _collection.merge)({
      a: 1
    }, undefined, {
      c: 3
    })).toEqual({
      a: 1,
      c: 3
    });
    expect((0, _collection.combine)({
      a: [1]
    }, undefined, {
      a: [2]
    })).toEqual({
      a: [1, 2]
    });
  });
  test('merge and combine work with simple arrays', function () {
    expect((0, _collection.merge)([0, 1], [1])).toEqual([1, 1]);
    expect((0, _collection.combine)([0, 1], [1])).toEqual([0, 1, 1]);
  });
  test('fill fills the missing properties of the given base' + ' from those of the extensions', function () {
    var baseProp = Symbol('baseProp');
    var underlayProp = Symbol('underlayProp');
    var overlayProp = Symbol('overlayProp');
    var base = mockObj(['a'], baseProp);
    var underlay = (0, _collection.secure)(mockObj(['a', 'b'], underlayProp));
    var overlay = (0, _collection.secure)(mockObj(['c'], overlayProp));
    var filled = (0, _collection.fill)(base, underlay, overlay);
    expect(filled).toEqual(base);
    expect(base).toEqual({
      a: baseProp,
      b: underlayProp,
      c: overlayProp
    });
  });
  test('flip swaps the keys and values of the given object', function () {
    expect((0, _collection.flip)(simpleObj)).toEqual({
      1: 'a',
      2: 'b'
    });
  });
  test('flipMany builds an one-to-one inverted mapping of' + ' a many to one object', function () {
    var oneToMany = {
      a: [1, 2]
    };
    var invertedOneToOne = {
      1: 'a',
      2: 'a'
    };
    expect((0, _collection.flipMany)(oneToMany)).toEqual(invertedOneToOne);
  });
  test('translate gives the translation of the source based' + ' on a translation map', function () {
    var translationMap = {
      welcome: "hello",
      farewell: "bye"
    };
    var data = {
      hola: "welcome"
    };
    expect((0, _collection.translate)(data, translationMap)).toEqual({
      "hola": "hello"
    });
  });
  test('rename renames the source keys based on' + ' the given rename map', function () {
    var data = {
      length: 1,
      breadth: 2
    };
    var renameMap = {
      length: "depth"
    };
    expect((0, _collection.rename)(data, renameMap)).toEqual({
      "depth": 1
    });
  });
  test('fromEntries builds an object out of entries', function () {
    expect((0, _collection.fromEntries)((0, _collection.entries)(simpleObj))).toEqual(simpleObj);
  });
  test('props returns an array of values for the given properties' + ' from the given object', function () {
    expect((0, _collection.props)(simpleObj, ['a', 'b'])).toEqual([1, 2]);
  });
  describe('select helps building sub-objects with selectors', function () {
    test('select returns a sub-object of the given object,' + ' with the given array of properties', function () {
      expect((0, _collection.select)(simpleObj, ['a'])).toEqual({
        a: 1
      });
    }); // #BREAKING: Treat objects and arrays similarly.

    test('select returns a sub-object of the given object,' + ' with the properties in the given selector object', function () {
      expect((0, _collection.select)(simpleObj, {
        a: 'some-thing',
        keyNotInSource: 'some value'
      })).toEqual({
        a: 1
      });
    });
    test('select returns a sub-array of the given array,' + ' with the given array of properties', function () {
      expect((0, _collection.select)(simpleArray, [0])).toEqual([1]);
    });
  });
  describe('omit helps building sub-objects through omitters', function () {
    test('omit returns a sub-object of the given object,' + ' without the given array of properties', function () {
      expect((0, _collection.omit)(simpleObj, ['a'])).toEqual({
        b: 2
      });
    }); // #BREAKING: Treat objects and arrays similarly.

    test('omit returns a sub-object of the given object,' + ' without the properties in the given selector object', function () {
      expect((0, _collection.omit)(simpleObj, {
        a: 'some-thing'
      })).toEqual({
        b: 2
      });
    });
    test('omit returns a sub-array of the given array,' + ' without the given array of properties', function () {
      expect((0, _collection.clean)((0, _collection.omit)(simpleArray, [0]))).toEqual([2]);
    });
  });
  test('result returns the value for the given simple path' + ' or escaped path', function () {
    expect((0, _collection.result)(complexObject, 'single')).toEqual(complexObject.single);
    expect((0, _collection.result)(complexObject, '/single')).toEqual(complexObject.single);
    expect((0, _collection.result)(complexObject, 'parent/child')).toEqual(complexObject.parent.child);
    expect((0, _collection.result)(complexObject, 'parent/\\/unescaped\\/child')).toEqual(complexObject.parent['/unescaped/child']);
    expect((0, _collection.result)(complexObject, 'parent/escaped\\\\\\/child')).toEqual(complexObject.parent['escaped\\/child']);
    expect((0, _collection.result)(complexObject, 'non-existent')).toEqual(undefined);
    expect((0, _collection.result)(complexObject, 'array/1')).toEqual(2);
    expect((0, _collection.result)({
      '': 1
    }, '/')).toEqual(1);
    expect((0, _collection.result)(complexObject, '')).toEqual(complexObject);
  });
  test('compose returns an object from a list of objects,' + ' with only keys from the first object and the values from' + ' the objects , with a ascending priority', function () {
    expect((0, _collection.compose)({
      a: 1,
      b: 2,
      c: 3
    }, {
      a: 2,
      b: 3
    }, {
      b: 2,
      d: 1
    })).toEqual({
      a: 2,
      b: 2,
      c: 3
    });
  });
  test('patch creates a new variation of a baseObject based on' + ' the given extension, while preserving them both', function () {
    var extension = {
      b: 3
    };
    expect((0, _collection.patch)(simpleObj, extension)).toEqual({
      a: 1,
      b: 3
    });
    expect(simpleObj).toEqual({
      a: 1,
      b: 2
    });
    expect(extension).toEqual({
      b: 3
    });
  });
  test('diff returns the difference between a baseObject' + ' and a comparedObject', function () {
    var difference = (0, _collection.diff)(baseObject, comparedObject);
    expect(difference).toEqual({
      b: 3,
      c: {
        d: 3
      },
      d: undefined,
      e: [undefined, 1],
      f: 'only in compared'
    }); // Verify the presence of missing keys.

    expect(difference).toHaveProperty('d');
  });
  test('diff and patch are complementary', function () {
    var difference = (0, _collection.diff)(baseObject, comparedObject);
    var patched = (0, _collection.patch)(baseObject, difference); // Verify the absence of missing keys.

    expect(patched).not.toHaveProperty('d');
    expect(patched).toEqual(comparedObject);
  });
  test('secure prevents further modifications to the given iterable', function () {
    var frozenObject = (0, _collection.secure)((0, _collection.clone)(complexObject));
    var frozenArray = frozenObject.array;
    var actions = {
      objectMutation: function objectMutation() {
        return frozenObject.parent.child = Symbol();
      },
      objectExtension: function objectExtension() {
        return frozenObject.parent.child1 = Symbol();
      },
      objectDeletion: function objectDeletion() {
        return delete frozenObject.parent.child;
      },
      arrayMutation: function arrayMutation() {
        return frozenArray[0] = Symbol();
      },
      arrayExtension: function arrayExtension() {
        return frozenArray.push(Symbol());
      },
      arrayDeletion: function arrayDeletion() {
        return frozenArray.pop();
      }
    };
    (0, _collection.map)(actions, function (action) {
      return expect(action).toThrow();
    });
  });
  test('contains tests the base object contains' + ' the compared object', function () {
    expect((0, _collection.contains)(1, 1)).toBe(true);
    expect((0, _collection.contains)(1, 0)).toBe(false);
    expect((0, _collection.contains)(complexObject, (0, _collection.clone)(complexObject))).toBe(true);
    expect((0, _collection.contains)(simpleObj, {})).toBe(true);
    expect((0, _collection.equals)({}, simpleObj)).toBe(false);
  });
  test('equals tests the value equality of primitives and' + ' complex objects', function () {
    expect((0, _collection.equals)(1, 1)).toBe(true);
    expect((0, _collection.equals)(1, 0)).toBe(false);
    expect((0, _collection.equals)(complexObject, (0, _collection.clone)(complexObject))).toBe(true);
    expect((0, _collection.equals)(simpleObj, {})).toBe(false);
    expect((0, _collection.equals)({}, simpleObj)).toBe(false);
  });
  test('hasSame tests the given collections for having' + ' the same children', function () {
    expect((0, _collection.hasSame)(complexArray, [].concat(complexArray))).toBe(true);
    expect((0, _collection.hasSame)(complexObject, _objectSpread({}, complexObject))).toBe(true);
    expect((0, _collection.hasSame)(complexArray, (0, _collection.clone)(complexArray))).toBe(false);
    expect((0, _collection.hasSame)(complexObject, (0, _collection.clone)(complexObject))).toBe(false);
  });
  test('gather gathers the given props from the children' + ' of the given iterable, as an iterable', function () {
    var arrayOfObjects = (0, _collection.secure)([{
      a: 1,
      b: 2
    }, {
      a: 2,
      b: 1
    }, {
      c: 3
    } // Objects do not hold references to undefined values.
    ]);
    var objectOfArrays = (0, _collection.secure)({
      a: [1, 2],
      b: [2, 1],
      c: [undefined, undefined, 3] // Arrays do hold references to undefined values, to preserve indices.

    });
    expect((0, _collection.gather)(arrayOfObjects, 'a', 'b', 'c')).toEqual(objectOfArrays);
    expect((0, _collection.gather)(objectOfArrays, 0, 1, 2)).toEqual(arrayOfObjects);
  });
  test('pick picks the given prop from the children of the given iterable,' + ' as an iterable', function () {
    var arrayOfObjects = (0, _collection.secure)([{
      a: 1
    }, {
      a: 2,
      b: 3
    }, {
      c: 4
    }]);
    expect((0, _collection.pick)(arrayOfObjects, 'a')).toEqual([1, 2]);
  });
  test('spread spreads the children of given iterables' + ' into the base iterable', function () {
    var base = {
      a: {},
      b: {}
    };
    var seeds = (0, _collection.secure)({
      prop1: {
        a: 1,
        b: 2
      },
      prop2: {
        a: 3,
        b: 4
      }
    });
    var seeded = (0, _collection.spread)(base, seeds);
    expect(seeded).toEqual({
      a: {
        prop1: 1,
        prop2: 3
      },
      b: {
        prop1: 2,
        prop2: 4
      }
    });
    expect(seeded).toEqual(base);
  });
  test('dict converts the given collection into a dictionary', function () {
    expect((0, _collection.dict)(simpleArray)).toEqual({
      0: 1,
      1: 2
    });
  });
  test('adopt copies values from extensions into the base', function () {
    var base = {};
    (0, _collection.adopt)(base, complexObject);
    (0, _collection.each)(base, function (value, key) {
      expect(value === complexObject[key]).toEqual(true);
    });
  });
  test('find finds the first element from the collection chose ' + ' by the predicate', function () {
    expect((0, _collection.find)(simpleObj, (0, _helpers.getPredicate)(2))).toBe(2);
    expect((0, _collection.find)(simpleObj, (0, _helpers.getPredicate)(3))).toBeUndefined();
    expect((0, _collection.find)(simpleArray, (0, _helpers.getPredicate)(2))).toBe(2);
    expect((0, _collection.find)(simpleArray, (0, _helpers.getPredicate)(3))).toBeUndefined();
  });
  test('findKey finds the key of first element from the collection chosen' + ' by the predicate', function () {
    expect((0, _collection.findKey)(simpleObj, (0, _helpers.getPredicate)(2))).toBe('b');
    expect((0, _collection.findKey)(simpleObj, (0, _helpers.getPredicate)(3))).toBeUndefined();
    expect((0, _collection.findKey)(simpleArray, (0, _helpers.getPredicate)(2))).toBe('1');
    expect((0, _collection.findKey)(simpleArray, (0, _helpers.getPredicate)(3))).toBeUndefined();
  });
  test('findIndex is an alias for findIndex', function () {
    expect(_collection.findIndex).toBe(_collection.findKey);
  });
  describe('range helps building number-series arrays', function () {
    var abs = Math.abs,
        floor = Math.floor;

    var getLength = function getLength(start, end, step) {
      return floor(abs(end - start) / abs(step));
    };

    var testRange = function testRange(result, start, end, step) {
      var length = getLength(start, end, step);
      expect(result.length).toBe(length);
      expect(result[0]).toBe(start);
      expect(result[length - 1]).toBe(start + (length - 1) * step);
    };

    var buildRange = function buildRange(starts, ends, steps) {
      var start = _lib.rndBetween.apply(void 0, (0, _toConsumableArray2["default"])(starts));

      var end = _lib.rndBetween.apply(void 0, (0, _toConsumableArray2["default"])(ends)) + start;

      var step = _lib.rndBetween.apply(void 0, (0, _toConsumableArray2["default"])(steps));

      var result = (0, _collection.range)(start, end, step);
      return [result, start, end, step];
    };

    test('range returns an array of numbers with the given start, end' + ' and step values', function () {
      testRange.apply(void 0, (0, _toConsumableArray2["default"])(buildRange([5, 9], [5, 9], [1, 3])));
    });
    test('range can return descending series', function () {
      testRange.apply(void 0, (0, _toConsumableArray2["default"])(buildRange([1, 10], [-10, -1], [-3, -1])));
    });
    test('range has default values for all parameters', function () {
      var start = 0;
      var end = 9;
      var step = 1;
      var length = getLength(start, end, step);
      var result = (0, _collection.range)();
      testRange(result, start, end, step);
    });
    describe('range returns an empty array when', function () {
      test('step is 0', function () {
        expect((0, _collection.range)(0, 0, 0)).toEqual([]);
      });
      test('start to end direction and step direction are different', function () {
        expect((0, _collection.range)(10, 1, 1)).toEqual([]);
      });
      test('start and end are the same', function () {
        (0, _collection.range)(-10, 10).map(function (num) {
          return expect((0, _collection.range)(num, num)).toEqual([]);
        });
      });
    });
  });
  test('shares tests whether the given objects share the same value' + ' on a given property', function () {
    expect((0, _collection.shares)(simpleObj, nestedObj, 'a')).toBe(true);
    expect((0, _collection.shares)(simpleObj, complexObject, 'a')).toBe(false);
  });
  test('shares uses \'id\' as the default property compare', function () {
    expect((0, _collection.shares)({
      id: 1
    }, {
      id: 1
    })).toBe(true);
  });
  describe('shuffle shuffles the given collection', function () {
    test('shuffle shuffles arrays', function () {
      var array = (0, _collection.range)(1, 100);
      var shuffled = (0, _collection.shuffle)(array);
      expect(shuffled).not.toEqual(array);
      expect((0, _helpers.sortArray)(shuffled)).toEqual((0, _helpers.sortArray)(array));
    });
    test('shuffle shuffles objects', function () {
      var obj = mockObj((0, _collection.range)(1, 100).map(function (i) {
        return '0' + i;
      }));
      var shuffled = (0, _collection.shuffle)(obj);
      var shuffledValues = (0, _collection.values)(shuffled);
      var objValues = (0, _collection.values)(obj);
      expect(shuffledValues).not.toEqual(objValues);
      expect((0, _helpers.sortArray)(shuffledValues)).toEqual((0, _helpers.sortArray)(objValues));
    });
  });
  describe('sort sorts the given collection', function () {
    test('sort sorts arrays', function () {
      var array = (0, _collection.range)(1, 100);
      var reversed = array.slice().reverse();
      var shuffled = (0, _collection.shuffle)(array);
      var sorted = (0, _collection.sort)(shuffled, _sorters.descending);
      expect(sorted).toEqual(reversed);
      expect(sorted).not.toBe(array);
    });
    test('sort sorts objects', function () {
      var obj = mockObj((0, _collection.range)(1, 100).map(function (i) {
        return '0' + i;
      }));
      var shuffled = (0, _collection.shuffle)(obj);
      var sorted = (0, _collection.sort)(shuffled, _sorters.ascending);
      var sortedValues = (0, _collection.values)(sorted);
      var objValues = (0, _collection.values)(obj);
      expect((0, _helpers.sortArray)(sortedValues)).toEqual((0, _helpers.sortArray)(objValues));
    });
    test('sort uses ascending as the default sorter', function () {
      var array = (0, _collection.range)(1, 100);
      var shuffled = (0, _collection.shuffle)(array);
      var sorted = (0, _collection.sort)(shuffled);
      expect(sorted).toEqual(array);
      expect(sorted).not.toBe(array);
    });
  });
});