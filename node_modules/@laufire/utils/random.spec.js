"use strict";

var _collection = require("./collection");

var _random = require("./random");

var _helpers = require("../test/helpers");

var _lib = require("./lib");

/* Tested */

/* Helpers */

/* Tests */
describe('rndBetween', function () {
  var isBetween = function isBetween(value, from, to) {
    expect(value >= from).toBe(true);
    expect(value <= to).toBe(true);
  };

  test('rndBetween returns a random integer between two integers', function () {
    var from = -10;
    var to = 10;
    (0, _helpers.retry)(function () {
      return isBetween((0, _random.rndBetween)(from, to), from, to);
    });
  });
  test('rndBetween defaults to 0 and 9 from and to values', function () {
    var from = 0;
    var to = 9;
    (0, _helpers.retry)(function () {
      return isBetween((0, _random.rndBetween)(), from, to);
    });
  });
});
test('rndString returns a random string of length 8,' + ' with the seed char, on default configuration.', function () {
  var seed = _random.stringSeeds["char"];
  (0, _helpers.retry)(function () {
    var rnd = (0, _random.rndString)();
    expect(rnd.length).toBe(8);
    expect((0, _helpers.strSubSet)(seed, rnd)).toBe(true);
  });
});
test('rndOfString returns a random sub-string of the given string.', function () {
  var seed = (0, _random.rndString)();
  var seedLength = seed.length;
  (0, _helpers.retry)(function () {
    var rnd = (0, _random.rndOfString)(seed);
    expect(rnd.length <= seedLength).toBe(true);
    expect(rnd.length >= 1).toBe(true);
    expect((0, _helpers.strSubSet)(seed, rnd)).toBe(true);
  });
});
describe('rndValue returns a random a value from the given iterable.', function () {
  test('returns a value when the iterable is not empty', function () {
    var seed = (0, _helpers.retry)(function (i) {
      return [i, (0, _random.rndString)()];
    }, 10);
    var array = (0, _collection.pick)(seed, 1);
    var object = (0, _collection.fromEntries)(seed);
    (0, _helpers.retry)(function () {
      expect(array).toContain((0, _random.rndValue)(array));
      expect(array).toContain((0, _random.rndValue)(object));
    });
    expect((0, _random.rndValue)([])).toBeUndefined();
    expect((0, _random.rndValue)({})).toBeUndefined();
  });
  test('returns undefined when the iterable is empty', function () {
    expect((0, _random.rndValue)([])).toBeUndefined();
    expect((0, _random.rndValue)({})).toBeUndefined();
  });
});
describe('rndValues returns the given count of random a values' + 'from the given iterable', function () {
  var seed = (0, _helpers.retry)(function (i) {
    return [i, (0, _random.rndString)()];
  }, 10);
  var array = (0, _collection.pick)(seed, 1);
  var object = (0, _collection.fromEntries)(seed);
  var length = seed.length;
  test('returns count number of values when the iterable length' + 'is longer than count', function () {
    var test = function test(iterable) {
      var count = (0, _random.rndBetween)(0, length - 1);
      var result = (0, _random.rndValues)(iterable, count);
      expect(result.length).toEqual(count);
      result.forEach(function (item) {
        return expect((0, _lib.values)(iterable)).toContain(item);
      });
    };

    (0, _helpers.retry)(function () {
      return [array, object].forEach(test);
    });
  });
  test('count is limited to the length of the source iterable', function () {
    var test = function test(iterable) {
      var count = seed.length * 2;
      var result = (0, _random.rndValues)(iterable, count);
      expect(result.length).toEqual(seed.length);
    };

    (0, _helpers.retry)(function () {
      return [array, object].forEach(test);
    });
  });
  test('count defaults to 1', function () {
    expect((0, _random.rndValues)(array).length).toEqual(1);
  });
});
describe('rndValueWeighted returns a random a value from' + ' the given weight table according to the given weights.', function () {
  test('returns a value when the iterable is not empty', function () {
    var weights = {
      a: 1,
      b: 2
    };
    var getRnd = (0, _random.rndValueWeighted)(weights);
    var results = (0, _helpers.retry)(getRnd, 1000);
    var counts = (0, _collection.map)(weights, function (dummy, key) {
      return results.filter(function (v) {
        return v === key;
      }).length;
    });
    expect(counts.a > 250).toEqual(true);
    expect(counts.b > 500).toEqual(true);
    expect((0, _random.rndValue)({})).toBeUndefined();
  });
  test('returns undefined when the iterable is empty', function () {
    expect((0, _random.rndValueWeighted)({})()).toBeUndefined();
  });
});
describe('withProb returns a function which returns true once in a while' + ' based on the given probability value.', function () {
  test('returns true based on the given probability.', function () {
    var probability = 0.3;
    var acceptableDeviation = 0.2;
    var retryCount = 10000;
    var isProbable = (0, _random.withProb)(probability);
    var results = (0, _helpers.retry)(isProbable, retryCount);
    var counts = results.filter(function (result) {
      return result === true;
    }).length;
    var prevalence = counts / retryCount;
    expect(prevalence > probability * (1 - acceptableDeviation)).toEqual(true);
    expect(prevalence < probability * (1 + acceptableDeviation)).toEqual(true);
  });
});